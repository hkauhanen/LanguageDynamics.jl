var documenterSearchIndex = {"docs":
[{"location":"interactors/","page":"Interactors","title":"Interactors","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"interactors/#Interactors","page":"Interactors","title":"Interactors","text":"","category":"section"},{"location":"interactors/","page":"Interactors","title":"Interactors","text":"Modules = [LanguageDynamics]\nPages = [\"Interactors/Interactors.jl\", \"Interactors/EmptyInteractor.jl\", \"Interactors/MomentumSelector.jl\"]","category":"page"},{"location":"interactors/#LanguageDynamics.characterize-Tuple{AbstractInteractor}","page":"Interactors","title":"LanguageDynamics.characterize","text":"characterize(x::AbstractInteractor)\n\nCharacterize the state of a single interactor. Calls the characterize method on the replicator carried by the interactor.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.EmptyInteractor","page":"Interactors","title":"LanguageDynamics.EmptyInteractor","text":"An empty interactor. This is an empty type that has no functionality apart from 'existing'. Its use case is testing and debugging population-dynamic functions; linguistically, empty interactors are inert. They can be rendezvoused, technically, but nothing happens.\n\n\n\n\n\n","category":"type"},{"location":"interactors/#LanguageDynamics.EmptyInteractor-Tuple{}","page":"Interactors","title":"LanguageDynamics.EmptyInteractor","text":"Construct an empty interactor.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.act!-Tuple{AbstractInteractor, EmptyInteractor}","page":"Interactors","title":"LanguageDynamics.act!","text":"act!(x::AbstractInteractor, y::EmptyInteractor)\n\nMake an interactor attempt an action on an EmptyInteractor. Does nothing and returns false.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.act!-Tuple{EmptyInteractor, AbstractInteractor}","page":"Interactors","title":"LanguageDynamics.act!","text":"act!(x::EmptyInteractor, y::AbstractInteractor)\n\nMake an EmptyInteractor attempt an action on another interactor. Does nothing and returns false.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.act!-Tuple{EmptyInteractor, EmptyInteractor}","page":"Interactors","title":"LanguageDynamics.act!","text":"act!(x::EmptyInteractor, y::EmptyInteractor)\n\nMake an EmptyInteractor attempt an action on another EmptyInteractor. Does nothing and returns false.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.MomentumSelector","page":"Interactors","title":"LanguageDynamics.MomentumSelector","text":"Momentum-based utterance selector, after Stadler et al. (2016).\n\nReference\n\nStadler, K., Blythe, R. A., Smith, K. & Kirby, S. (2016) Momentum in language change: a model of self-actuating s-shaped curves. Language Dynamics and Change, 6, 171–198. https://doi.org/10.1163/22105832-00602005\n\n\n\n\n\n","category":"type"},{"location":"interactors/#LanguageDynamics.MomentumSelector-Tuple{Float64, Float64, Float64, Int64, Float64}","page":"Interactors","title":"LanguageDynamics.MomentumSelector","text":"MomentumSelector(alpha::Float64, gamma::Float64, b::Float64, T::Int, x0::Float64)\n\nConstruct a MomentumSelector with learning rate alpha, short-term memory smoothing factor gamma, momentum bias b, number of utterances per interaction T, and initial frequency x0.\n\n\n\n\n\n","category":"method"},{"location":"interactors/#LanguageDynamics.act!-Tuple{MomentumSelector, MomentumSelector}","page":"Interactors","title":"LanguageDynamics.act!","text":"act!(x::MomentumSelector, y::MomentumSelector)\n\nLet one MomentumSelector act upon another, i.e. x speaks and y listens.\n\n\n\n\n\n","category":"method"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"philosophy/#Philosophy","page":"Philosophy","title":"Philosophy","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"The design philosophy of LanguageDynamics.jl follows David Hull's general theory of selection and its application to cultural evolution in the domain of language (see references below). There are three main types of objects: replicators, interactors and populations. In a typical case, a replicator could be a grammatical parameter, interactors would be individual speakers, and the population would correspond to a community of first-language learners; typically, we are interested in tracking how the relative frequencies of different replicators evolve through interactions between the interactors that make up the population. This framework is intended to be maximally general, however. In a more macroscopic application, for example, we could take the interactors to be entire languages.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"info: Info\nA population is a container of interactors, which are containers of replicators. Replicators reproduce in the population through interactions between interactors, mediated by the structure of the population.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"LanguageDynamics.jl defines an entire hierarchy of types. Replicators are composite types derived from the abstract AbstractReplicator type or one of its abstract descendants. Similarly, interactors derive ultimately from AbstractInteractor and populations from AbstractPopulation. All non-abstract replicator, interactor and population types must implement certain functions to guarantee unified behaviour, as discussed next.","category":"page"},{"location":"philosophy/#The-nature-of-populations","page":"Philosophy","title":"The nature of populations","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Every population type is required to descend from AbstractPopulation and to minimally implement the following:","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"A field named census, which is an Array of objects descending from AbstractInteractor.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Three functions are defined for AbstractPopulation and hence available to all populations:","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"A function inject!(x,y), which inserts interactor object x into population y.\nA function eject!(x,y), which removes interactor with census index x from population y.\nA function rendezvous!(x), which triggers an interaction between randomly chosen interactors in population x.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Populations can redefine these through their own methods, and add further methods not implemented in the abstract. For example, network populations (descendants of AbstractNetworkPopulation) must have methods for connecting and disconnecting interactors). The specific requirements for implementing particular abstract types are detailed in the documentation for each abstract type.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"warning: Warning\nGiven this implementation, the indices of interactors in the census variable will change if interactors are removed from the population. The array implementation was chosen for performance reasons – an alternative implementation using a Dict and unique keys, for example, would be orders of magnitude slower. If time-persistent unique interactor identifiers are needed, this should be accomplished through external book-keeping.","category":"page"},{"location":"philosophy/#The-nature-of-interactors","page":"Philosophy","title":"The nature of interactors","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Every interactor type is required to descend from AbstractInteractor and to minimally implement the following:","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"A field named replicator, of a type T that descends from AbstractReplicator.\nA method or methods act!(x,y), which specifies/specify how interactor x acts on interactor y.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"An exception is the EmptyInteractor type which does not implement a replicator.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"Many interactor types require that x and y above be of the same type T. However, sometimes x, y or both can refer to all descendants of an abstract type with which it makes sense for an interactor of type T to interact.","category":"page"},{"location":"philosophy/#The-nature-of-replicators","page":"Philosophy","title":"The nature of replicators","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"FIXME","category":"page"},{"location":"philosophy/#Rendezvous-and-actions","page":"Philosophy","title":"Rendezvous and actions","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"In LanguageDynamics.jl, interactions between interactors typically arise through calls to a rendezvous! function implemented in the population whose members those interactors are. This function then calls upon act! functions implemented in the interactors, which in turn may modify the replicators contained in the interactors.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"For instance, suppose we have a population x whose implementation of rendezvous!(x) is to pick two interactors from the census at random and to make both act upon each other if, and only if, some condition C is satisfied. Calling rendezvous!(x) would then first check for C and, if satisfied, proceed to call both act!(a,b) and act!(b,a), where a and b are the two randomly drawn interactors. The effect of the action functions would depend on the types of the interactors. Suppose, for example, that both speakers are utterance selectors; then a acting on b has the effect of a producing a number of utterances and b updating its replicator based on that action.","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"info: Info\nActions are in general asymmetric: act!(a,b) cannot be assumed to have the same effect as act!(b,a).","category":"page"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"warning: Warning\nRendezvous functions are used to prompt interactors to act upon each other. Whether any tangible action in fact occurs may depend on the satisfaction of some set of conditions, as explained above.","category":"page"},{"location":"philosophy/#References","page":"Philosophy","title":"References","text":"","category":"section"},{"location":"philosophy/","page":"Philosophy","title":"Philosophy","text":"(Hull, Croft, maybe Michaud?)","category":"page"},{"location":"auxiliaries/","page":"Auxiliaries","title":"Auxiliaries","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"auxiliaries/#Auxiliaries","page":"Auxiliaries","title":"Auxiliaries","text":"","category":"section"},{"location":"auxiliaries/","page":"Auxiliaries","title":"Auxiliaries","text":"Modules = [LanguageDynamics]\nPages = [\"common.jl\"]","category":"page"},{"location":"auxiliaries/#LanguageDynamics.Point","page":"Auxiliaries","title":"LanguageDynamics.Point","text":"A 2D point of type T; has fields x and y, both of type T. A frequent use case is Point{Int} for a point in the two-dimensional Cartesian product of integers.\n\n\n\n\n\n","category":"type"},{"location":"auxiliaries/#LanguageDynamics.chebyshev-Tuple{Point{Int64}, Point{Int64}}","page":"Auxiliaries","title":"LanguageDynamics.chebyshev","text":"chebyshev(x::Point{Int}, y::Point{Int})\n\nFind the Chebyshev distance between two integer points.\n\n\n\n\n\n","category":"method"},{"location":"auxiliaries/#LanguageDynamics.manhattan-Tuple{Point{Int64}, Point{Int64}}","page":"Auxiliaries","title":"LanguageDynamics.manhattan","text":"manhattan(x::Point{Int}, y::Point{Int})\n\nFind the Manhattan distance between two integer points.\n\n\n\n\n\n","category":"method"},{"location":"auxiliaries/#LanguageDynamics.zipf-Tuple{Int64, Float64}","page":"Auxiliaries","title":"LanguageDynamics.zipf","text":"zipf(N::Int, s::Float64)\n\nZipf's Law for N elements and scaling exponent s, i.e. the probability mass function\n\nf(k s N) = H_Ns^-1 k^-s\n\nfor k = 1 dots  N, where H_Ns is the generalized harmonic  number used for normalization.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"To install the latest version of LanguageDynamics from the Julia REPL, hit ] to enter Pkg mode and type:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"pkg> add https://github.com/hkauhanen/LanguageDynamics.jl","category":"page"},{"location":"getting-started/#Simple-example:-a-pool-of-people","page":"Getting started","title":"Simple example: a pool of people","text":"","category":"section"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"index-eventual/#LanguageDynamics","page":"LanguageDynamics","title":"LanguageDynamics","text":"","category":"section"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"LanguageDynamics is a Julia package for exploring the population dynamics of language by means of agent-based simulations. It implements several common models of language acquisition, use and change (such as utterance selection and variational learning) in a variety of community structures ranging from fully mixing \"pools\" of speakers to spatial populations and multiplex networks. To facilitate extending the library with custom types and function, minimal restrictions are placed on what objects may interface with what other objects.","category":"page"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"The Getting started section provides installation instructions and a simple usage example. The Philosophy page explains the design philosophy of LanguageDynamics in more detail. A number of further use cases are illustrated under Examples. The Reference pages provide documentation for all available functions and objects.","category":"page"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"LanguageDynamics.jl is free and open-source software, licensed under the MIT license.","category":"page"},{"location":"index-eventual/#How-to-cite","page":"LanguageDynamics","title":"How to cite","text":"","category":"section"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"If you find this software useful and would like to reference it, please consider citing the following paper:","category":"page"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"FIXME","category":"page"},{"location":"index-eventual/#Contributing","page":"LanguageDynamics","title":"Contributing","text":"","category":"section"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"If you've found a bug or have a feature request, please file an issue.","category":"page"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"If you'd like to contribute code, feel free to fork the repository and submit a pull request, or drop Henri a message.","category":"page"},{"location":"index-eventual/#Acknowledgements","page":"LanguageDynamics","title":"Acknowledgements","text":"","category":"section"},{"location":"index-eventual/","page":"LanguageDynamics","title":"LanguageDynamics","text":"Preparation of this software has been supported by the Federal Ministry of Education and Research (BMBF) and the Baden-Württemberg Ministry of Science as part of the Excellence Strategy of the German Federal and State Governments; and by the European Research Council (project STARFISH, grant no. FIXME).","category":"page"},{"location":"roadmap/#Roadmap-a.k.a.-stuff-to-implement","page":"Roadmap a.k.a. stuff to implement","title":"Roadmap a.k.a. stuff to implement","text":"","category":"section"},{"location":"roadmap/#Meta-stuff","page":"Roadmap a.k.a. stuff to implement","title":"Meta stuff","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap a.k.a. stuff to implement","title":"Roadmap a.k.a. stuff to implement","text":"some easy way of dumping simulation outcomes and/or snapshots to CSV files\nmulti-threading / distributed execution (at least in documentation, if not on the level of code)\nsome easy way of handling parameters and reading parameter files","category":"page"},{"location":"roadmap/#Types","page":"Roadmap a.k.a. stuff to implement","title":"Types","text":"","category":"section"},{"location":"roadmap/","page":"Roadmap a.k.a. stuff to implement","title":"Roadmap a.k.a. stuff to implement","text":"Naming Game\nVL\nUSM\nNetwork population types\nTLA?\nCue-based learning (Lightfoot, Mitchener)?\nTypes for more complex grammars (replicators)\nRM dynamics?\nThe simple frequency matcher agent from Kauhanen 2017?\nKauhanen's and Michaud's well-behavedness measures\nexemplar dynamics?","category":"page"},{"location":"populations/","page":"Populations","title":"Populations","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"populations/#Populations","page":"Populations","title":"Populations","text":"","category":"section"},{"location":"populations/","page":"Populations","title":"Populations","text":"Modules = [LanguageDynamics]\nPages = [\"Populations/Populations.jl\", \"Populations/PoolPopulation.jl\", \"Populations/ZipfTravellerPopulation.jl\"]","category":"page"},{"location":"populations/#LanguageDynamics.characterize-Tuple{AbstractPopulation}","page":"Populations","title":"LanguageDynamics.characterize","text":"characterize(x::AbstractPopulation)\n\nCharacterize the state of a population. Tries to form either a single number or a vector that reflects the population's average behaviour, depending on the types of replicators carried by the interactions in the population. In practice, this is achieved by calling on characterize functions on the interactors.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.characterize_by_location-Tuple{LanguageDynamics.AbstractLatticePopulation}","page":"Populations","title":"LanguageDynamics.characterize_by_location","text":"characterize_by_location(x::AbstractLatticePopulation)\n\nCharacterize a lattice population cell by cell.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.eject!-Tuple{AbstractPopulation}","page":"Populations","title":"LanguageDynamics.eject!","text":"eject!(x::AbstractPopulation)\n\nRemove a randomly chosen interactor from a population.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.eject!-Tuple{Int64, AbstractPopulation}","page":"Populations","title":"LanguageDynamics.eject!","text":"eject!(x::Int, y::AbstractPopulation)\n\nRemove interactor with ID x from population y.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.inject!-Tuple{AbstractInteractor, AbstractPopulation}","page":"Populations","title":"LanguageDynamics.inject!","text":"inject!(x::AbstractInteractor, y::AbstractPopulation)\n\nAdd an interactor to a population.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.rendezvous!-Tuple{AbstractPopulation, Int64, Int64}","page":"Populations","title":"LanguageDynamics.rendezvous!","text":"rendezvous!(x::AbstractPopulation, y::Int, z::Int)\n\nConduct a rendezvous between interactors indexed by y and z in population x. (The first mentioned acts first.)\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.rendezvous!-Tuple{AbstractPopulation}","page":"Populations","title":"LanguageDynamics.rendezvous!","text":"rendezvous!(x::AbstractPopulation)\n\nConduct a rendezvous between two interactors chosen at random in population x.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.PoolPopulation","page":"Populations","title":"LanguageDynamics.PoolPopulation","text":"A pool population is a well-mixing finite community, i.e. one in which every interactor is connected to every other interactor and the probability of interaction is uniform.\n\n\n\n\n\n","category":"type"},{"location":"populations/#LanguageDynamics.PoolPopulation-Union{Tuple{}, Tuple{T}} where T<:AbstractInteractor","page":"Populations","title":"LanguageDynamics.PoolPopulation","text":"PoolPopulation{T}()\n\nConstruct an empty pool population of interactors of type T.\n\nExamples\n\nPoolPopulation{EmptyInteractor}()\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.ZipfTravellerPopulation","page":"Populations","title":"LanguageDynamics.ZipfTravellerPopulation","text":"A 'Zipfian traveller population': interactors are located on a two-dimensional lattice. Each interactor has a 'home' cell on the lattice, but also has the option of travelling to another cell. The probability to travel to a cell with coordinates x and y scales as the inverse of the distance between that cell and the interactor's home (coordinates x and y), measured as the Manhattan distance d:\n\nP propto frac1(1 + d)^lambda\n\nwhere lambda is a scaling parameter. Interactors only rendezvous with other interactors currently residing in the same cell.\n\n\n\n\n\n","category":"type"},{"location":"populations/#LanguageDynamics.ZipfTravellerPopulation-Union{Tuple{Int64, Float64}, Tuple{T}} where T<:AbstractInteractor","page":"Populations","title":"LanguageDynamics.ZipfTravellerPopulation","text":"ZipfTravellerPopulation(K::Int, lambda::Float64)\n\nConstruct a Zipf traveller population of size K by K with scaling parameter lambda.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.eject!-Tuple{Int64, ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.eject!","text":"eject!(x::Int, y::ZipfTravellerPopulation)\n\nRemove an interactor from a Zipf traveller population.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.inject!-Tuple{AbstractInteractor, ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.inject!","text":"inject!(x::AbstractInteractor, y::ZipfTravellerPopulation)\n\nInsert an interactor into a Zipf traveller population.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.rendezvous!-Tuple{ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.rendezvous!","text":"rendezvous!(x::ZipfTravellerPopulation)\n\nRendezvous in a Zipf traveller population (between two random interactors currently in the same cell).\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.travel!-Tuple{Int64, ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.travel!","text":"travel!(x::Int, y::ZipfTravellerPopulation)\n\nMake interactor with index x travel in a Zipf traveller population.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.travel!-Tuple{ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.travel!","text":"travel!(x::ZipfTravellerPopulation)\n\nMake a random interactor in a Zipf traveller population travel.\n\n\n\n\n\n","category":"method"},{"location":"populations/#LanguageDynamics.travel_all!-Tuple{ZipfTravellerPopulation}","page":"Populations","title":"LanguageDynamics.travel_all!","text":"travel_all!(x::ZipfTravellerPopulation)\n\nMake every interactor in a Zipf traveller population travel.\n\n\n\n\n\n","category":"method"},{"location":"type-hierarchies/","page":"The type hierarchies","title":"The type hierarchies","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"type-hierarchies/#type-hierarchies","page":"The type hierarchies","title":"The type hierarchies","text":"","category":"section"},{"location":"abstract-types/","page":"Abstract types","title":"Abstract types","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"abstract-types/#Abstract-types","page":"Abstract types","title":"Abstract types","text":"","category":"section"},{"location":"abstract-types/","page":"Abstract types","title":"Abstract types","text":"Modules = [LanguageDynamics]\nPages = [\"AbstractReplicators.jl\", \"AbstractInteractors.jl\", \"AbstractPopulations.jl\"]","category":"page"},{"location":"abstract-types/#LanguageDynamics.AbstractReplicator","page":"Abstract types","title":"LanguageDynamics.AbstractReplicator","text":"Abstract replicator. The top node of the Replicator type hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractInteractor","page":"Abstract types","title":"LanguageDynamics.AbstractInteractor","text":"Abstract interactor. The top node of the Interactor type hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractLanguage","page":"Abstract types","title":"LanguageDynamics.AbstractLanguage","text":"Abstract language: an interactor that is a language (community).\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractProbabilisticSpeaker","page":"Abstract types","title":"LanguageDynamics.AbstractProbabilisticSpeaker","text":"Abstract probabilistic speaker: a speaker containing a probabilistic replicator.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractSpeaker","page":"Abstract types","title":"LanguageDynamics.AbstractSpeaker","text":"Abstract speaker: an interactor that is an individual.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractUtteranceSelector","page":"Abstract types","title":"LanguageDynamics.AbstractUtteranceSelector","text":"Abstract utterance selector: an interactor of the Utterance Selection Model type.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractLatticePopulation","page":"Abstract types","title":"LanguageDynamics.AbstractLatticePopulation","text":"Abstract lattice population: interactors on some lattice.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractNetworkPopulation","page":"Abstract types","title":"LanguageDynamics.AbstractNetworkPopulation","text":"Abstract network population. Interactors are nodes of some network.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractPopulation","page":"Abstract types","title":"LanguageDynamics.AbstractPopulation","text":"Abstract population. The top node of the Population type hierarchy.\n\n\n\n\n\n","category":"type"},{"location":"abstract-types/#LanguageDynamics.AbstractSpatialPopulation","page":"Abstract types","title":"LanguageDynamics.AbstractSpatialPopulation","text":"Abstract spatial population. Represents any type of population in which interactors have a spatial representation (e.g. a point on a plane).\n\n\n\n\n\n","category":"type"},{"location":"examples/","page":"Examples","title":"Examples","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"yoyoyo","category":"page"},{"location":"replicators/","page":"Replicators","title":"Replicators","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"replicators/#Replicators","page":"Replicators","title":"Replicators","text":"","category":"section"},{"location":"replicators/","page":"Replicators","title":"Replicators","text":"Modules = [LanguageDynamics]\nPages = [\"Replicators/BinaryVariable.jl\"]","category":"page"},{"location":"replicators/#LanguageDynamics.BinaryVariable","page":"Replicators","title":"LanguageDynamics.BinaryVariable","text":"A binary variable of type T.\n\n\n\n\n\n","category":"type"},{"location":"replicators/#LanguageDynamics.characterize-Tuple{BinaryVariable}","page":"Replicators","title":"LanguageDynamics.characterize","text":"characterize(x::BinaryVariable)\n\nCharacterize a binary variable.\n\n\n\n\n\n","category":"method"},{"location":"all/","page":"All functions and types","title":"All functions and types","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"all/#All-functions-and-types","page":"All functions and types","title":"All functions and types","text":"","category":"section"},{"location":"all/","page":"All functions and types","title":"All functions and types","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = LanguageDynamics","category":"page"},{"location":"#LanguageDynamics","page":"Home","title":"LanguageDynamics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LanguageDynamics.jl is a Julia package for exploring the population dynamics of language by means of agent-based simulations. It implements several common models of language acquisition, use and change (such as utterance selection and variational learning) in a variety of community structures ranging from fully mixing \"pools\" of speakers to spatial populations and multiplex networks. To facilitate extending the library with custom types and functions, minimal restrictions are placed on what objects may interface with what other objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Getting started section provides installation instructions and a simple usage example. The Philosophy page explains the design philosophy of LanguageDynamics.jl in more detail. A number of further use cases are illustrated under Examples. The Reference pages provide documentation for all available functions and objects.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nLanguageDynamics.jl is in the very early stages of its development. Expect stuff to break and change over time. Most design principles of the package have yet to be set in stone, and versions in the 0.1.x series in particular must not be considered stable in any way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LanguageDynamics.jl is free and open-source software, licensed under the MIT license.","category":"page"}]
}
